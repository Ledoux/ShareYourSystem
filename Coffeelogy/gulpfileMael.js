// Generated by CoffeeScript 1.9.2
var _, browserify, cacheify, coffeeify, coffeelint, concat, db, es, explorationServerLibs, gulp, gutil, handleErrors, isProd, level, libDashboardSources, minifyCSS, ngAnnotate, notify, prefix, publish, rename, sass, source, sources, streamify, uglify, vendorLibs;

gulp = require('gulp');

gutil = require('gulp-util');

browserify = require('browserify');

source = require('vinyl-source-stream');

sass = require('gulp-ruby-sass');

ngAnnotate = require('gulp-ng-annotate');

rename = require('gulp-rename');

concat = require('gulp-concat');

es = require('event-stream');

prefix = require('gulp-autoprefixer');

coffeelint = require('gulp-coffeelint');

uglify = require('gulp-uglify');

minifyCSS = require('gulp-minify-css');

_ = require('lodash');

streamify = require('gulp-streamify');

cacheify = require('cacheify');

coffeeify = require('coffeeify');

level = require('level');

db = level('./.gulp-cache');

notify = require('gulp-notify');

handleErrors = function() {
  notify.onError({
    title: 'Compile error',
    message: '<%= error.message %>'
  }).apply(this, Array.prototype.slice.call(arguments));
  return this.emit('end');
};

libDashboardSources = {
  coffeeWatch: ['app/columbus/columbus/**/*.coffee'],
  js: ['app/columbus/dist/*.js'],
  templates: ['app/columbus/columbus/**/*.html'],
  assets: ['app/columbus/columbus/styles/**/*.{eot,svg,ttf,woff}'],
  stylesLoadPaths: ['app/columbus'],
  stylesWatch: ['app/columbus/columbus/styles/**/*']
};

sources = {
  coffee: ['app/scripts/main.coffee'],
  coffeeWatch: ['app/scripts/**/*.coffee'].concat(libDashboardSources.coffeeWatch),
  templates: ['app/scripts/**/*.html'],
  styles: ['app/styles/main.scss'],
  stylesLoadPaths: ['app/styles'].concat(libDashboardSources.stylesLoadPaths),
  stylesWatch: ['app/styles/**/*'].concat(libDashboardSources.stylesWatch),
  assets: {
    html: ['app/*.html'],
    icon: ['app/*.ico'],
    images: ['app/images/**/*.{ico,svg,png,jpg}']
  },
  assetsWatch: ['app/*.html', 'app/images/**/*.{ico,svg,png}']
};

explorationServerLibs = ['app/vendor/coffee-script.js', 'app/vendor/sass.min.js'];

vendorLibs = [
  {
    name: 'modernizr',
    js: 'bower_components/modernizr/modernizr.js'
  }, {
    name: 'jquery',
    js: 'bower_components/jquery/jquery.js'
  }, {
    name: 'angular',
    js: ['bower_components/angular/angular.js', 'bower_components/angular-route/angular-route.js']
  }, {
    name: 'explorationServer',
    js: 'bower_components/ngstorage/ngStorage.js'
  }, {
    name: 'dat.gui',
    js: 'app/vendor/dat.gui.js'
  }, {
    name: 'animate.css',
    css: 'bower_components/animate.css/animate.css'
  }, {
    name: 'ng-json-explorer',
    css: 'app/vendor/ng-json-explorer/gd-ui-jsonexplorer.css',
    js: 'app/vendor/ng-json-explorer/gd-ui-jsonexplorer.js'
  }, {
    name: 'Columbus dependencies',
    js: 'app/columbus/dist/columbusDependencies.js',
    css: 'app/columbus/dist/columbusDependencies.css'
  }, {
    name: 'sweetalert',
    css: 'bower_components/sweetalert/lib/sweet-alert.css',
    js: 'bower_components/sweetalert/lib/sweet-alert.js'
  }, {
    name: 'CalHeatMap',
    js: 'app/vendor/cal-heatmap/cal-heatmap.js',
    css: 'app/vendor/cal-heatmap/cal-heatmap.css'
  }
];

isProd = gutil.env.type === 'prod';

gulp.task('lint', function() {
  return gulp.src(['app/scripts/**/*.coffee']).pipe(coffeelint()).pipe(coffeelint.reporter());
});

publish = function(folder) {
  var awspublish, fs, parallelize;
  awspublish = require('gulp-awspublish');
  parallelize = require('concurrent-transform');
  fs = require('fs');
  return fs.readFile(process.env.HOME + '/.s3cfg', 'utf-8', function(err, data) {
    var auth, bucketPath, fieldName, force, i, keys, len, line, publisher, ref, splitIdx, value;
    if (err) {
      console.log(err);
      return;
    }
    keys = {};
    ref = data.split('\n');
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      splitIdx = line.indexOf('=');
      if (splitIdx >= 0) {
        fieldName = line.slice(0, +(splitIdx - 1) + 1 || 9e9).trim().toLowerCase();
        value = line.slice(splitIdx + 1).trim();
        if (fieldName.length > 0) {
          keys[fieldName] = value;
        }
      }
    }
    auth = {
      accessKeyId: keys['access_key'],
      secretAccessKey: keys['secret_key'],
      params: {
        Bucket: 'private-snips-net'
      }
    };
    publisher = awspublish.create(auth);
    force = gutil.env.force === 'true';
    bucketPath = function(path) {
      path.dirname = ("Traces/" + folder + "/") + path.dirname;
      return path;
    };
    return gulp.src(['dist/**/*']).pipe(rename(bucketPath)).pipe(awspublish.gzip()).pipe(parallelize(publisher.publish({
      'Content-Encoding': 'gzip',
      'x-amz-acl': 'private'
    }, {
      force: force
    }), 10)).pipe(awspublish.reporter());
  });
};

gulp.task('publish-develop', function() {
  if (!isProd) {
    throw new Error('ERROR: you can only use publish in production mode, use `gulp --type prod publish`');
  }
  return publish('researchVisualization-develop');
});

gulp.task('publish-master', function() {
  if (!isProd) {
    throw new Error('ERROR: you can only use publish in production mode, use `gulp --type prod publish`');
  }
  return publish('researchVisualization-master');
});

gulp.task('dashboard-templates', function() {
  return gulp.src(libDashboardSources.templates).pipe(gulp.dest('dist/columbus/scripts'));
});

gulp.task('dashboard-styles-assets', function() {
  return gulp.src(libDashboardSources.assets).pipe(gulp.dest('dist/styles'));
});

gulp.task('vendor', function() {
  var assets, css, files, js, ref, type;
  ref = (function() {
    var i, len, ref, results;
    ref = ['js', 'css', 'assets'];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      files = _.filter(_.pluck(vendorLibs, type));
      files = _.map(files, function(t) {
        if (_.isArray(t)) {
          return t;
        } else {
          return [t];
        }
      });
      results.push(_.reduce(files, function(t, acc) {
        return t.concat(acc);
      }));
    }
    return results;
  })(), js = ref[0], css = ref[1], assets = ref[2];
  gulp.src(js).pipe(isProd ? ngAnnotate() : gutil.noop()).pipe(isProd ? uglify() : gutil.noop()).pipe(concat('vendor.js')).pipe(gulp.dest('dist/scripts'));
  return gulp.src(css).pipe(prefix("last 2 versions", "> 1%")).pipe(isProd ? minifyCSS() : gutil.noop()).pipe(concat('vendor.css')).pipe(gulp.dest('dist/styles'));
});

gulp.task('explorationServerVendor', function() {
  return gulp.src(explorationServerLibs).pipe(concat('explorationServerVendor.js')).pipe(gulp.dest('dist/scripts'));
});

gulp.task('scripts', function() {
  var bundler, transform;
  transform = isProd ? coffeeify : cacheify(coffeeify, db);
  bundler = browserify({
    entries: ['./scripts/main.coffee'],
    debug: !isProd,
    basedir: './app',
    paths: ['./columbus/'],
    extensions: ['.js', '.coffee'],
    ignoreMissing: true
  }).transform(transform);
  return bundler.bundle().on('error', handleErrors).on('error', gutil.log).on('error', gutil.beep).pipe(source('main.js')).pipe(isProd ? streamify(ngAnnotate()) : gutil.noop()).pipe(isProd ? streamify(uglify()) : gutil.noop()).pipe(gulp.dest('dist/scripts')).pipe(notify('Finished compiling scripts'));
});

gulp.task('styles', function() {
  return sass(sources.styles, {
    loadPath: sources.stylesLoadPaths
  }).on('error', handleErrors).on('error', gutil.log).pipe(prefix("last 2 versions", "> 1%")).on('error', handleErrors).on('error', gutil.log).on('error', gutil.beep).pipe(isProd ? minifyCSS() : gutil.noop()).pipe(gulp.dest('dist/styles')).pipe(notify('Finished compiling styles'));
});

gulp.task('app-assets', function() {
  var assets;
  assets = sources.assets;
  return es.concat(gulp.src(assets.html).pipe(gulp.dest('dist/')), gulp.src(assets.icon).pipe(gulp.dest('dist/')), gulp.src(assets.images).pipe(gulp.dest('dist/images')));
});

gulp.task('app-templates', function() {
  return gulp.src(sources.templates).pipe(gulp.dest('dist/scripts'));
});

gulp.task('watch', function() {
  gulp.watch(sources.coffeeWatch, ['scripts']);
  gulp.watch(libDashboardSources.js, ['vendor']);
  gulp.watch(libDashboardSources.templates, ['dashboard-templates']);
  gulp.watch(libDashboardSources.assets, ['dashboard-styles-assets']);
  gulp.watch(sources.templates, ['app-templates']);
  gulp.watch(sources.stylesWatch, ['styles']);
  return gulp.watch(sources.assetsWatch, ['app-assets']);
});
