// Generated by CoffeeScript 1.9.2

/*

  Import modules
 */

(function() {
  var MainObject, _, brequire, browserify, cjsx, cjsxDir, cjsxfy, coffee, coffeeify, concat, connect, cssSources, dev_vendorLibs, findPath, gulp, gutil, htmlSources, importCss, isProd, lodash, minifyCSS, ngAnnotate, path, prefix, rename, sass, sassSources, scriptSources, source, transform, uglify, watchify;

  path = require('path');

  gulp = require('gulp');

  gutil = require('gulp-util');

  sass = require('gulp-sass');

  watchify = require('watchify');

  lodash = require('lodash');

  browserify = require('browserify');

  source = require('vinyl-source-stream');

  transform = require('vinyl-transform');

  cjsx = require('gulp-cjsx');

  coffee = require('gulp-coffee');

  coffeeify = require('coffeeify');

  cjsxfy = require('coffee-reactify');

  connect = require('gulp-connect');

  uglify = require('gulp-uglify');

  concat = require('gulp-concat');

  importCss = require('gulp-import-css');

  minifyCSS = require('gulp-minify-css');

  ngAnnotate = require('gulp-ng-annotate');

  prefix = require('gulp-autoprefixer');

  concat = require('gulp-concat');

  _ = require('lodash');

  rename = require('gulp-rename');


  /*
  
    define the environment
   */

  isProd = gutil.env.type === 'prod';


  /*
  
    define the vendor
   */

  dev_vendorLibs = [
    {
      name: 'lodash',
      js: 'node_modules/lodash/lodash.js'
    }
  ];


  /*
  
    Say where to watch and to write
   */

  cssSources = ['styles/*.css'];

  sassSources = ['styles/*.scss'];

  htmlSources = ['**/*.html'];

  scriptSources = ['scripts/**/*.cjsx', 'scripts/**/*.coffee', 'scripts/**/*.js'];

  MainObject = {
    entries: ['./scripts/main.js'],
    extensions: ['.js', '.coffee', '.cjsx']
  };


  /*
  
    Define change tasks
   */

  gulp.task('log', function() {
    return gutil.log('== My First Task ==');
  });

  gulp.task('copy', function() {
    return gulp.src('index.html').pipe(gulp.dest, assetsDir);
  });

  gulp.task('sass', function() {
    return gulp.src(sassSources).pipe(sass({
      style: 'expanded'
    })).on('error', gutil.log).pipe(gulp.dest('assets')).pipe(connect.reload());
  });

  gulp.task('css', function() {
    return gulp.src(cssSources).pipe(importCss()).pipe(gulp.dest('assets')).pipe(connect.reload());
  });

  cjsxDir = null;

  findPath = function(file, t) {
    cjsxDir = file.path;
    return console.log(cssDir);
  };

  gulp.task('cjsx', function() {
    return gulp.src(scriptSources).pipe(tap(findPath)).pipe(cjsx({
      bare: true
    }).on('error', gutil.log)).pipe(gulp.dest(cjsxDir));
  });

  gulp.task('html', function() {
    return gulp.src(htmlSources).pipe(connect.reload());
  });

  gulp.task('coffeeGulp', function() {
    return gulp.src(['gulpfile.coffee']).pipe(coffee({
      bare: true
    }).on('error', gutil.log)).pipe(gulp.dest(""));
  });


  /*
  gulp.task 'dev_vendor_bundle',
  	->
  		browserify(
    				["./assets/empty.js"],
    				{
    					#debug: false,
    					#extensions: ['.js', '.coffee', '.cjsx']
    				}
    		)
    		.on('prebundle', (bundle) -> 
    			vendorLibs.forEach(external) ->
    				if external.expose?
    					bundle.require(external.require, expose: external.expose)
    				else
    					bundle.require(external.require)
    		)
    		.bundle()
    		.pipe(source('dev_vendor.js'))
    		.pipe(gulp.dest("assets"))
   */

  brequire = function(pathname) {
    var filename;
    console.log('pathname is ' + pathname);
    filename = pathname.split('/').slice(-1)[0];
    console.log('filename is ' + filename);
    return browserify(pathname).require(filename, {
      expose: pathname
    }).bundle();
  };

  gulp.task('dev_vendor_bundle', function() {
    var assets, browserified, css, files, js, ref, type;
    ref = (function() {
      var i, len, ref, results;
      ref = ['js', 'css', 'assets'];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        type = ref[i];
        files = _.filter(_.pluck(dev_vendorLibs, type));
        files = _.map(files, function(t) {
          if (_.isArray(t)) {
            return t;
          } else {
            return [t];
          }
        });
        results.push(_.reduce(files, function(t, acc) {
          return t.concat(acc);
        }));
      }
      return results;
    })(), js = ref[0], css = ref[1], assets = ref[2];
    if (js !== void 0 && js.length > 0) {
      browserified = transform(brequire);
      return gulp.src(js).pipe(isProd ? ngAnnotate() : gutil.noop()).pipe(isProd ? uglify() : gutil.noop()).pipe(browserified).pipe(concat('dev_vendor.js')).pipe(gulp.dest('assets'));
    }
    if (css !== void 0 && css.length > 0) {
      return gulp.src(css).pipe(prefix("last 2 versions", "> 1%")).pipe(isProd ? minifyCSS() : gutil.noop()).pipe(concat('dev_vendor.css')).pipe(gulp.dest('assets'));
    }
  });

  gulp.task('iframe_vendor_bundle', function() {
    return browserify(['./node_modules/react/react.js', './node_modules/lodash/lodash.js']).bundle().pipe(source('iframe_vendor.js')).pipe(gulp.dest('assets'));
  });

  gulp.task('main_bundle', function() {
    var MainBrowserify, MainWatchify;
    MainBrowserify = browserify(lodash.assign({}, watchify.args, MainObject));
    return MainWatchify = watchify(MainBrowserify).transform(cjsxfy).bundle().pipe(source('buffer.js')).pipe(gulp.dest('assets')).pipe(connect.reload());
  });

  gulp.task('main_min', function() {
    return gulp.src(['assets/buffer.js']).pipe(uglify()).pipe(concat('main.min.js')).pipe(gulp.dest('assets')).pipe(connect.reload());
  });


  /*
  
    Define watch connect
   */

  gulp.task('watch', function() {
    gulp.watch(cssSources, ['css']);
    gulp.watch(scriptSources, ['main_bundle']);
    return gulp.watch(htmlSources, ['html']);
  });

  gulp.task('connect', function() {
    return connect.server({
      root: '.',
      livereload: true
    });
  });


  /*
  
    Define global tasks
   */

  gulp.task('default', ['dev_vendor_bundle', 'html', 'main_bundle', 'css', 'connect', 'watch']);

}).call(this);
